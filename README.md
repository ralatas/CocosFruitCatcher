# Catch the Falling Fruits (Cocos Creator 3.8, TS, ECS)

Тестовое задание: игра «Поймай падающие фрукты» на **Cocos Creator 3.8** с использованием **TypeScript** (strict) и лёгкого ECS (**miniplex**) для управления игровыми сущностями.

> В архиве только кодовая база (TS + конфиги). Сцену, префабы и подключение скриптов нужно настроить в редакторе Cocos Creator.

---

## Структура проекта

```text
assets/
  scripts/
    core/
      ecs/
        components.ts      # Компоненты и тип Entity (фрукты, корзина, траектории, опасные объекты)
        world.ts           # Экземпляр мира miniplex + основные запросы (queries)
        systems/
          BasketControlSystem.ts  # Движение корзины по целевой X-позиции (мышь/тач)
          MovementSystem.ts       # Применение velocity к position + перемещение Node
          TrajectorySystem.ts     # Реализация трёх типов траекторий
          SpawnSystem.ts          # Спавн фруктов и опасных объектов
          CollisionSystem.ts      # Обработка ловли фруктов корзиной (очки и жизни)
          CleanupSystem.ts        # Удаление улетевших за пределы экрана сущностей
          TimerSystem.ts          # Обновление игрового таймера
      game/
        GameConfig.ts       # Конфигурация игры (длительность, жизни, параметры фруктов)
        GameState.ts        # Доменная логика: счёт, жизни, таймер, Game Over
    entry/
      GameRoot.ts           # Композиционный корень, связывает ECS, GameState и Cocos-сцену
```

---

## Архитектурные решения (кратко)

1. **Лёгкий ECS (miniplex)**  
   Использую `miniplex` как лёгкий ECS-слой: сущности — plain-объекты, компоненты — свойства, выборки делаются через `world.with(...)`.  
   Это позволяет легко добавлять новые типы сущностей (бонусы, новые типы врагов/фруктов) без переписывания существующих систем.

2. **Чёткое разделение домена и представления**  
   - Домен: `GameState` и `GameConfig` не зависят от Cocos API.  
   - Представление: Cocos-компоненты (`GameRoot`, Label’ы и префабы) только подписываются на события домена и обновляют UI.  
   Это упрощает тестирование и облегчает поддержку.

3. **Системы по Single Responsibility**  
   Каждый System отвечает за одну зону логики: движение, траектории, спавн, коллизии, таймер и т.п.  
   Это соответствует принципу **Single Responsibility** и позволяет легко изменять порядок выполнения систем в `GameRoot.update`.

4. **Инъекция зависимостей вместо глобальных синглтонов**  
   `GameState` и конфиг передаются в системы через конструктор (`SpawnSystem`, `CollisionSystem`, `TimerSystem`).  
   Это снижает связность и упрощает тестирование / переиспользование систем в другом контексте.

5. **Вариативность через явные абстракции**  
   - Типы фруктов и траекторий оформлены как `enum` (`FruitKind`, `TrajectoryKind`).  
   - Логика спавна и очков завязана на конфиг (`GameConfig`), а не на «магические числа» в системах.  
   Добавление нового фрукта или новой траектории — это расширение конфигурации и/или switch по enum, без изменения базовой структуры.

---

## Как подключить в Cocos Creator

1. Создайте новый 2D-проект в **Cocos Creator 3.8**.
2. Скопируйте содержимое этой папки в корень проекта (особенно `assets/` и файлы `package.json`, `tsconfig.json`).
3. В корне проекта выполните:

   ```bash
   npm install
   ```

4. В редакторе:
   - Создайте сцену с `Canvas`.
   - На `Canvas` повесьте компонент `GameRoot` (`assets/scripts/entry/GameRoot.ts`).
   - Создайте префабы:
     - Корзина (`basketPrefab`) — Node с картинкой корзины.
     - Фрукты (`applePrefab`, `bananaPrefab`, `orangePrefab`) — по одному префабу на тип фрукта.
     - Опасный объект (`hazardPrefab`) — префаб мухомора/бомбы.
   - Создайте 3 `Label`’а на Canvas и привяжите их к полям `scoreLabel`, `timerLabel`, `livesLabel` в `GameRoot`.
   - Укажите ссылки на префабы и `Canvas` в инспекторе компонента `GameRoot`.

После этого игра должна запускаться и работать: фрукты/опасные объекты падают по разным траекториям, корзина двигается по мыши/тачу, идёт подсчёт очков, времени и жизней.

---

## Известные ограничения и возможные улучшения

- Коллизии реализованы упрощённо (по позициям и ширине корзины). Можно заменить на точные 2D-коллайдеры Cocos.
- Анимации и звуки не реализованы (их можно добавить как отдельные компоненты/системы, не меняя основную архитектуру ECS).
- Сейчас используется один уровень сложности. Его можно вынести в конфиг и масштабировать (изменять скорости, интервал спавна, вероятность опасных объектов).

---

## Использование AI

Часть архитектуры и первоначальные шаблоны кода были сгенерированы с помощью ChatGPT и затем адаптированы вручную:  
- структура папок и разделение домена/представления,  
- базовые сигнатуры систем и компонентов,  
- некоторые фрагменты TypeScript-кода.

Далее код был доработан и приведён к единому стилю, чтобы соответствовать требованиям тестового и соблюсти принципы SOLID/ООП.

Подробнее промпты и влияние AI описаны в файле `PROMPTS.md`.
